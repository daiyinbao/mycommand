#!/usr/bin/env bash

proto_filter=""
kill_mode=0
args=()

# 参数解析
for arg in "$@"; do
  case "$arg" in
    -t) proto_filter="tcp" ;;
    -u) proto_filter="udp" ;;
    -k) kill_mode=1 ;;
    *) args+=("$arg") ;;
  esac
done

# 获取端口信息
data=$(ss -lntup 2>/dev/null | awk -v PF="$proto_filter" '
NR>1 {
  proto=$1
  state=$2
  local=$5    # ss 输出最后一列才是本地地址（IPv4/IPv6）
  line=$0

  if(state!="LISTEN") next
  if(PF!="" && proto!=PF) next

  # 去掉 IPv6 的 []
  gsub(/\[|\]/,"",local)

  # 提取端口（最后冒号后面的数字）
  port="-"
  tmp=local
  sub(/.*:/,"",tmp)
  port=tmp

  # 提取 PID
  pid="-"
  if(line ~ /pid=/){
    tmp=line
    sub(/.*pid=/,"",tmp)
    sub(/[^0-9].*/,"",tmp)
    pid=tmp
  }

  # 提取进程名
  name="-"
  if(line ~ /users:\(\("/){
    tmp=line
    sub(/.*users:\(\("/,"",tmp)
    sub(/".*/,"",tmp)
    name=tmp
  }

  printf "%-6s %-5s %-6s %s\n", port, proto, pid, name
}')

# 过滤端口/进程名
filtered=$(echo "$data" | awk -v ARGS="${args[*]}" '
BEGIN { n=split(ARGS,a," ") }
{
  port=$1; line=$0
  port_ok=0; name_ok=0

  for(i=1;i<=n;i++){
    arg=a[i]
    if(arg ~ /^[0-9]+-[0-9]+$/){
      split(arg,r,"-")
      if(port>=r[1] && port<=r[2]) port_ok=1
    } else if(arg ~ /^[0-9]+$/){
      if(port==arg) port_ok=1
    } else {
      if(tolower(line) ~ tolower(arg)) name_ok=1
    }
  }

  if(n==0) print
  else if(port_ok || name_ok) print
}')

# kill 模式
if [ "$kill_mode" -eq 1 ]; then
  pids=$(echo "$filtered" | awk '{print $3}' | grep -v -e '^-$' | sort -u)
  if [ -z "$pids" ]; then
    echo "no killable processes found"
    exit 0
  fi

  echo "The following processes will be terminated:"
  echo "$filtered" | awk '{printf "  PID %-6s  %s (port %s)\n",$3,$4,$1}'

  read -p "Proceed? [y/N] " ans
  [[ "$ans" =~ ^[Yy]$ ]] || exit 0

  for pid in $pids; do
    if kill -0 "$pid" 2>/dev/null; then
      kill "$pid" && echo "killed $pid"
    else
      echo "no permission to kill $pid"
    fi
  done
  exit 0
fi

# 输出表格
printf "%-6s %-5s %-6s %s\n" "PORT" "PROTO" "PID" "PROCESS"
echo "$filtered" | sort -u -k1,1 -k4,4

